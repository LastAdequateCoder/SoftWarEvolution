using System.Collections.Immutable;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using InterpreterModules;
using InterpreterModules.interpreter;

/// <summary>
/// Custom visitor for COBOL parse trees that extends the base visitor generated by ANTLR.
/// </summary>
public class CustomVisitor : cobolBaseVisitor<object> 
{
    public CustomVisitor(Dictionary<string, IParseTree> procedures){
        this.procedures = procedures;
    }

    private Dictionary<string, Value> _valueHashMap = new Dictionary<string, Value>();
    private Dictionary<string, IParseTree> procedures;
    private Signal signal = new Signal();

    public override object VisitDisplay([NotNull] cobolParser.DisplayContext context)
    {
        int len = context.withnoadvancing() == null ? context.ChildCount : context.ChildCount - 1;
        for (int i = 1; i < len; i++)
        {
            string text = context.GetChild(i).GetText().ToUpper();
            if(char.IsLetter(text[0])){
                Value value;
                _valueHashMap.TryGetValue(text, out value);
                if (value == null)
                    throw new Exception("Incorrect variable name!");
                System.Console.WriteLine(value.Val + " ");
            }
            else{
                System.Console.WriteLine(text + " ");
            }
        }
        if (context.withnoadvancing == null){
            Console.WriteLine("\n");
        }
        return DefaultResult;
    }
    //Problem for now is that i dnot understand how to fill _valueHashMap. it is actuallu null
    //and when trying to get a value from _hashmap we get an object with a null reference
    public override object VisitAdd([NotNull] cobolParser.AddContext context)
    {
        string key;
        key = context.giving() == null ?
            context.identifiers().GetText().ToUpper() : context.giving().identifiers().GetText().ToUpper();

        Value value;
        _valueHashMap.TryGetValue(key, out value);
        if (value != null && !value.IsNumerical())
            throw new ValueIsNotNumericalException();

        int newValue;

        
        if (context.giving() != null)
        {
            newValue = int.Parse(context.@base.Text.Trim());
        }
        else
        {
            newValue = value.Val == null ? 0 : int.Parse(value.Val);
        }

        for(int i = 0; i < context._additions.Count; i++)
        {
            //Potential problems with Text property
            newValue += Int32.Parse(
                context._additions[i].Text.Trim()
                );
        }

        if (value == null){
            value = new Value(newValue.ToString());
        }
        else{
            value.AssignValue(newValue.ToString());
        }
        _valueHashMap[key] = value;

        return DefaultResult;
    }

    public override object VisitAccept([NotNull] cobolParser.AcceptContext context){
        for (int i = 0; i < context.identifiers().Count(); i++)
        {
            if (context.identifiers()[i] != null){
                Value oldValue;
                _valueHashMap.TryGetValue(context.identifiers()[i].GetText().ToUpper(), out oldValue);
                if (_valueHashMap.ContainsKey(context.identifiers()[i].GetText().ToUpper())){
                    //TODO: Console.ReadLine is probably not the best solution
                    Value newValue = new Value(Console.ReadLine(), oldValue.Picture);
                    if (Value.CheckValueWithPicture(newValue.Val, oldValue.Picture)){
                        _valueHashMap[context.identifiers()[i].GetText().ToUpper()] = newValue;
                    }
                    else{
                        throw new Exception("Value does not correspond to the picture!");
                    }
                }
                else{
                    throw new Exception("The variable was not found!");
                }
            }
            else{
                throw new Exception("No variables provided!");
            }
        }

        return DefaultResult;
    }

    public override object VisitData_division([NotNull] cobolParser.Data_divisionContext context)
    {
        // No variables
        if (context.variables().Count() == 0){
            return base.VisitData_division(context);
        }

        String parent = "";
        int highestLevel = int.Parse(context.variables(0).level().GetText());
        var variablesContexts = context.variables();
        for (int i = 0; i < variablesContexts.Count(); i++)
        {
             if (int.Parse(variablesContexts[i].level().GetText()) == highestLevel)
             {
                 parent = variablesContexts[i].IDENTIFIER().GetText();
             }
             String picture = "";
             if (variablesContexts[i].picture() != null){
                 picture = variablesContexts[i].picture().REPRESENTATION().GetText();
             }
             else if (variablesContexts[i].like() != null){
                 Value likeValue;
                 _valueHashMap.TryGetValue(variablesContexts[i].like().identifiers().GetText(), out likeValue);
                 if (likeValue != null){
                     picture = likeValue.Picture;
                 }
                 else{
                     throw new Exception("Can not assign picture from a given variable");
                 }

             }
             else if (i+1 < variablesContexts.Count() && int.Parse(variablesContexts[i+1].level().GetText()) == highestLevel){
                 throw new Exception("Picture was expected but not given!");
             }
             else if (i+1 > variablesContexts.Count()){
                 throw new Exception("The variable was not properly defined. Use picture or like for definying!");
             }

             if (picture != ""){
                 String value = Value.MakeValueByPicture(picture);
                 if (variablesContexts[i].occurs() != null){
                     for (int j = 0; j < int.Parse(variablesContexts[i].occurs().INT().GetText()); j++)
                     {
                         String variable = variablesContexts[i].IDENTIFIER().GetText();
                         variable += "[" + j + "]";
                         if (int.Parse(variablesContexts[i].level().GetText()) > highestLevel)
                             variable+="OF"+parent;
                         _valueHashMap.Add(variable.ToUpper(), new Value(value, picture));
                     }
                 }
                 else{
                     String variable = variablesContexts[i].IDENTIFIER().GetText();
                     if (int.Parse(variablesContexts[i].level().GetText()) > highestLevel)
                         variable+="OF"+parent;
                     _valueHashMap.Add(variable.ToUpper(), new Value(value, picture));
                 }
             }
        }
        return base.VisitData_division(context);
    }

    public override object VisitMultiply([NotNull] cobolParser.MultiplyContext context)
    {
        string key;
        Value valueObj;
        int newValue;

        if (context.giving() == null)
        {
            for(int i = 0; i < context.identifiers().Length; i++)
            {
                key = context.identifiers()[i].GetText().ToUpper();
                valueObj = _valueHashMap[key];
                if (!valueObj.IsNumerical())
                    return new ValueIsNotNumericalException();

                newValue = Convert.ToInt32(valueObj.Val);

                newValue *= Convert.ToInt32(context.multiplier.Text.Trim());
                valueObj.AssignValue(newValue.ToString());
                _valueHashMap[key] = valueObj;
            }
        }
        else
        {
            key = context.giving().identifiers().GetText().ToUpper();
            //valueObj = _valueHashMap[key];
            _valueHashMap.TryGetValue(key, out valueObj);
            if (valueObj != null && !valueObj.IsNumerical())
                throw new ValueIsNotNumericalException();
            newValue = Convert.ToInt32(context.@base.Text.Trim());
            newValue *= Convert.ToInt32(context.multiplier.Text.Trim());

            if (valueObj == null){
                valueObj = new Value(newValue.ToString());
            }
            else{
                valueObj.AssignValue(newValue.ToString());
            }
            _valueHashMap[key] = valueObj;
        }
        return DefaultResult;
    }

    public override object VisitSubtract(cobolParser.SubtractContext context)
    {
        String key;
        Value valueObj;
        int newValue;

        key = context.giving() != null ? 
            context.giving().identifiers().GetText().ToUpper() : context.identifiers().GetText().ToUpper();

        //valueObj = _valueHashMap[key];
        _valueHashMap.TryGetValue(key, out valueObj);
        if (valueObj!=null && !valueObj.IsNumerical())
            throw new ValueIsNotNumericalException();

        if (context.giving() != null)
        {
            newValue = Convert.ToInt32(context.@base.Text.Trim());
        }
        else
        {
            newValue = valueObj.Val == null ? 0 : Convert.ToInt32(valueObj.Val);
        }
        
        for (int i = 0; i < context._subtractors.Count; i++)
        {
            newValue -= Convert.ToInt32(context._subtractors[i].Text.Trim());
        }
        
        if (valueObj == null){
            valueObj = new Value(newValue.ToString());
        }
        else{
            valueObj.AssignValue(newValue.ToString());
        }
        _valueHashMap[key] = valueObj;
        
        return base.VisitSubtract(context);
    }

    public override object VisitDivide(cobolParser.DivideContext context)
    {
        String key;
        String remainderKey;
        Value valueObj;
        int newValue;
        int remainder;

        if (context.giving() == null)
        {
            for (int i = 0; i < context.identifiers().Length; i++)
            {
                key = context.identifiers()[i].GetText().ToUpper();
                valueObj = _valueHashMap[key];
                
                if (!valueObj.IsNumerical())
                    return new ValueIsNotNumericalException();

                if (valueObj.Val == null)
                {
                    throw new Exception("Value is empty. Can not divide.");
                }
                else
                {
                    newValue = Convert.ToInt32(valueObj.Val);
                }

                newValue /= Convert.ToInt32(context.divisor.Text.Trim());
                valueObj.AssignValue(newValue.ToString());
                _valueHashMap[key] = valueObj;
            }
        }
        else
        {
            key = context.giving().identifiers().GetText().ToUpper();
            
            _valueHashMap.TryGetValue(key, out valueObj);
            if (valueObj != null && !valueObj.IsNumerical())
                throw new ValueIsNotNumericalException();

            newValue = Convert.ToInt32(context.@base.Text.Trim());
            newValue /= Convert.ToInt32(context.divisor.Text.Trim());
            
            if (valueObj == null){
                valueObj = new Value(newValue.ToString());
            }
            
            valueObj.AssignValue(newValue.ToString());
            
            _valueHashMap[key] = valueObj;

            if (context.remainder() != null)
            {
                remainderKey = context.remainder().identifiers().GetText();

                _valueHashMap.TryGetValue(key, out valueObj);
                if (valueObj != null && !valueObj.IsNumerical())
                    throw new ValueIsNotNumericalException();

                remainder = Convert.ToInt32(context.@base.Text.Trim()) % Convert.ToInt32(context.divisor.Text.Trim());
                
                if (valueObj == null){
                    valueObj = new Value(newValue.ToString());
                }
                valueObj.AssignValue(remainder.ToString());
                _valueHashMap[remainderKey] = valueObj;

            }
            
        }
        
        
        return base.VisitDivide(context);
    }

    public override object VisitArithmetic_expression([NotNull] cobolParser.Arithmetic_expressionContext context)
    {
        if (context.atomic() != null){
            if (context.atomic().INT() != null){
                return int.Parse(context.atomic().INT().GetText());
            }
            return int.Parse(_valueHashMap[context.atomic().identifiers().GetText().ToUpper()].Val);
        }
        int left = (int)Visit(context.arithmetic_expression(0));
        int right = (int)Visit(context.arithmetic_expression(1));
        if (context.ARITHMETIC_OPERATOR().GetText() == "+"){
            return left + right;
        }
        else if (context.ARITHMETIC_OPERATOR().GetText() == "-"){
            return left - right;
        }
        else if (context.ARITHMETIC_OPERATOR().GetText() == "*"){
            return left*right;
        }
        else if (context.ARITHMETIC_OPERATOR().GetText() == "/"){
            return left/right;
        }
        else if (context.ARITHMETIC_OPERATOR().GetText() == "**"){
            return Math.Pow(left, right);
        }
        return DefaultResult;
    }

    public override object VisitBoolean([NotNull] cobolParser.BooleanContext context)
    {
        if (context.GetText().ToUpper() == "TRUE")
            return true;
        if (context.GetText().ToUpper() == "FALSE")
            return false;
        if (context.arithmetic_expression() != null){
            int left = (int)Visit(context.arithmetic_expression(0));
            int right = (int)Visit(context.arithmetic_expression(1));

            if (context.COMPARISON_OPERATOR().GetText() == "="){
                return left == right;
            }
            else if (context.COMPARISON_OPERATOR().GetText() == "<="){
                return left <= right;
            }
            else if (context.COMPARISON_OPERATOR().GetText() == "<"){
                return left < right;
            }
            else if (context.COMPARISON_OPERATOR().GetText() == ">"){
                return left > right;
            }
            else if (context.COMPARISON_OPERATOR().GetText() == ">="){
                return left >= right;
            }
        }
        if (context.GetText().ToUpper().StartsWith("NOT"))
            return !(bool)Visit(context.boolean(0));
        if (context.boolean() != null){
            bool left = (bool)Visit(context.boolean(0));
            bool right = (bool)Visit(context.boolean(1));
            if (context.BOOLEAN_OPERATOR().GetText() == "OR"){
                return left || right;
            }
            else if (context.BOOLEAN_OPERATOR().GetText() == "XOR"){
                return left ^ right;
            }
            else if (context.BOOLEAN_OPERATOR().GetText() == "AND"){
                return left&&right;
            }
        }
        return DefaultResult;
    }

    public override object VisitIf([NotNull] cobolParser.IfContext context)
    {
        bool condition = (bool)Visit(context.boolean());
        if (condition){
            if (context._i != null){
                foreach (cobolParser.StatementContext statementContext in context._i){
                    Visit(statementContext);
                }
            }
        }
        else{
            if (context._e != null){
                foreach (cobolParser.StatementContext statementContext in context._e)
                {
                    Visit(statementContext);
                }
            }
        }
        return DefaultResult;
    }

    public override object VisitEvaluate([NotNull] cobolParser.EvaluateContext context)
    {
        if(context.ALSO().Length == 0){
            Object condition = Visit(context.expressions(0));
            foreach (cobolParser.When_blockContext w in context.when_block())
            {
                if (w.atomic() != null){
                    if (condition.ToString().Equals(w.atomic(0).GetText())){
                        foreach (cobolParser.StatementContext s in w.statement())
                        {
                            Visit(s);
                        }
                        return DefaultResult;
                    }
                }
                else
                {
                    foreach (cobolParser.StatementContext s in w.statement())
                        {
                            Visit(s);
                        }
                        return DefaultResult;
                }
            }
        }
        else{
            int also = context.ALSO().Length;
            List<Object> conditions = new List<object>();
            foreach (cobolParser.ExpressionsContext e in context.expressions())
            {
                conditions.Add(Visit(e));
            }
            foreach (cobolParser.When_blockContext w in context.when_block()){
                int wAlso = w.ALSO().Length;
                if (also != wAlso)
                    throw new Exception("Incorrect amount of ALSO in when block!");
                if (w.atomic() != null){
                    bool conditionFlag = true;
                    for (int i = 0; i < conditions.Count; i++)
                    {
                        if(!conditions[i].ToString().Equals(w.atomic(i).GetText())){
                            conditionFlag = false;
                        }
                    }
                    if (conditionFlag){
                        foreach (cobolParser.StatementContext s in w.statement())
                        {
                            Visit(s);
                        }
                        return DefaultResult;
                    }
                }
                else{
                    foreach (cobolParser.StatementContext s in w.statement())
                    {
                        Visit(s);
                    }
                    return DefaultResult;
                }
            }
        }
        return DefaultResult;
    }

    public override object VisitStop([NotNull] cobolParser.StopContext context)
    {
        throw new StopException("The application was signaled to stop!");
    }

    public override object VisitNext_sentence([NotNull] cobolParser.Next_sentenceContext context)
    {
        throw new NextSentenceException("Next sentence was signaled!");
    }

    public override object VisitSentence([NotNull] cobolParser.SentenceContext context)
    {
        try{
            VisitChildren(context);
        }
        catch(NextSentenceException){
        }
        return DefaultResult;
    }

    public override object VisitPerform([NotNull] cobolParser.PerformContext context)
    {
        if (context.times() == null){
            if (context.through() == null){
                string name = context.proc().GetText();
                if (!procedures.ContainsKey(name)){
                    throw new Exception("Illegal procedure name!");
                }
                Visit(procedures[name]);
            }
            else{
                performThrough(context);
            }
        }
        else{
            int times = int.Parse(context.times().INT().GetText());
            if (context.through() == null){
                string name = context.proc().GetText();
                for (int i = 0; i < times; i++)
                {
                    if (!procedures.ContainsKey(name)){
                        throw new Exception("Illegal procedure name!");
                    }
                    Visit(procedures[name]);
                }
            }
            else{
                for (int i = 0; i < times; i++)
                {
                    performThrough(context);
                }
            }
        }
        return DefaultResult;
    }

    private void performThrough([NotNull] cobolParser.PerformContext context){
        string from = context.proc().GetText();
        string to = context.through().proc().GetText();
        if (!procedures.ContainsKey(from)){
            throw new Exception("Illegal procedure name!");
        }
        if (!procedures.ContainsKey(to)){
            throw new Exception("Illegal procedure name!");
        }

        List<IParseTree> toVisit = new List<IParseTree>();
        bool inBetween = false;
        foreach (var item in procedures)
        {
            if (item.Key.Equals(from)){
                inBetween = true;
            }
            if (inBetween){
                toVisit.Add(item.Value);
            }
            if (item.Key.Equals(to)){
                inBetween = false;
            }
        }
        if (inBetween){
            throw new Exception("Could not find second procedure!");
        }
        toVisit.ForEach(item => Visit(item));
    }

    bool varyLoop = false;
    public override object VisitLoop([NotNull] cobolParser.LoopContext context)
    {
        varyLoop = false;
        while (true) {
            try {
                VisitChildren(context);
            } catch (NextSentenceException e) {
                return DefaultResult;
            }
            catch (ExitLoopException e){
                return DefaultResult;
            }
        }
    }

    public override object VisitLoop_varying_expression([NotNull] cobolParser.Loop_varying_expressionContext context)
    {
        int from = 1, by = 1;
        int to = int.MaxValue;
        string loopVar = context.identifiers().GetText();

        if (context.from != null)
        {
            from = int.Parse(context.from.INT().GetText());
        }
        if (context.to != null)
        {
            to = int.Parse(context.to.INT().GetText());
        }
        if (context.by != null)
        {
            by = int.Parse(context.by.INT().GetText());
        }

        from--;
        to--;

        if (!varyLoop)
        {
            if (!_valueHashMap.TryGetValue(loopVar, out Value loopVarObj) || !loopVarObj.IsNumerical())
            {
                throw new InvalidOperationException("Loop variable is not numerical");
            }

            loopVarObj.AssignValue(from.ToString());
            _valueHashMap[loopVar] = loopVarObj;
            varyLoop = true;
        }

        if (!_valueHashMap.TryGetValue(loopVar, out Value loopVarObjUpdated) || !loopVarObjUpdated.IsNumerical())
        {
            throw new InvalidOperationException("Loop variable is not numerical");
        }
        int loopIdx = int.Parse(loopVarObjUpdated.Val);
        if (loopIdx > to)
        {
            throw new ExitLoopException("Exit Varying Loop");
        }
        loopVarObjUpdated.AssignValue((loopIdx + by).ToString());
        _valueHashMap[loopVar] = loopVarObjUpdated;

        return DefaultResult;
    }

    public override object VisitLoop_while_expression(cobolParser.Loop_while_expressionContext context)
    {
        bool condition = (bool)Visit(context.boolean());
        if (!condition)
        {
            throw new ExitLoopException("Exit While Loop");
        }
        return DefaultResult;
    }

    public override object VisitLoop_until_expression(cobolParser.Loop_until_expressionContext context)
    {
        bool condition = (bool)Visit(context.boolean());
        if (condition)
        {
            throw new ExitLoopException("Exit Until Loop");
        }
        return DefaultResult;
    }

    public override object VisitGoto([NotNull] cobolParser.GotoContext context)
    {
        if (_valueHashMap.ContainsKey(context.IDENTIFIER().GetText())){
            string variable = _valueHashMap[context.IDENTIFIER().GetText()].Val;
            if (procedures.ContainsKey(variable)){
                throw new GoToException(variable);
            }
        }
        if (procedures.ContainsKey(context.IDENTIFIER().GetText())){
            throw new GoToException(context.IDENTIFIER().GetText());
        }
        throw new Exception("No relevant identifier found!");
    }

    public override object VisitProcedure_division([NotNull] cobolParser.Procedure_divisionContext context)
    {
        int current = 0;
        while (current < context.ChildCount){
            try{
                Visit(context.GetChild(current));
                current++;
                signal.isSet = false;
            }
            catch (GoToException e){
                int i = 0;
                bool found = false;
                for (; i < context.ChildCount; i++)
                {
                    if (context.GetChild(i).GetText().StartsWith(e.Message + ".")){
                        current = i;
                        found = true;
                        break;
                    }
                }
                if (!found)
                    throw new Exception("Failed to find: " + e.Message);
            }
            catch (Exception e){
                if (signal.procedure != null && signal.isSet == false){
                    bool found = false;
                    int i = 0;
                    for (; i < context.ChildCount; i++)
                    {
                        if (context.GetChild(i).GetText().StartsWith(signal.procedure + ".")){
                            current = i;
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        throw new Exception("Failed to find: " + signal.procedure);
                    signal.isSet = true;
                }
                else{
                    throw;
                }
            }
        }
        return DefaultResult;
    }

    public override object VisitMove([NotNull] cobolParser.MoveContext context)
    {
        string val = "";
        VariableParser variableParser = new VariableParser();
        if (context.INT() != null){
            val = context.INT().GetText();
        }
        else if (context.singlevar() != null){
            string variableName = variableParser.ParseSingleVar(context.singlevar());
            val = _valueHashMap[variableName].Val;
        }

        List<string> multivar = variableParser.ParseMultiVar(context.multivar().identifiers().ToList(),
         _valueHashMap.Keys);

        if (!multivar.Any()){
            throw new Exception("No multivar given!");
        }

        foreach (string name in multivar){
            Value current = _valueHashMap[name];

            if (context.SPACES() != null){
                val = Value.BuildSpacesOnPicture(current.Picture);
            } 
            else if (context.HIGH_VALUES() != null){
                val = Value.BuildHighValueOnPicture(current.Picture);
            }
            else if (context.LOW_VALUES() != null){
                val = Value.BuildLowValueOnPicture(current.Picture);
            }
            else{
                if (!Value.CheckValueWithPicture(val, current.Picture)){
                    throw new Exception("Move value is not matching the picture!");
                }
            }
            current.AssignValue(val);
            _valueHashMap[name] = current;
        }
        return DefaultResult;
    }

    public override object VisitAlter([NotNull] cobolParser.AlterContext context)
    {
        string from = context.proc(0).GetText();
        string to = context.proc(1).GetText();

        if (from == null || to == null){
            throw new Exception("Incorrect procedure initialization in ALTER");
        }

        if (!procedures.ContainsKey(from) || !procedures.ContainsKey(to)){
            throw new Exception("Procedures were not found in the text of the program!");
        }

        IParseTree tree = procedures[from];
        if (tree.GetChild(4) == null){
            if(tree.GetChild(2).GetText().StartsWith("GO TO")){
                procedures.Add(from, procedures[to]);
            }
        }
        return DefaultResult;
    }

    public override object VisitSignal([NotNull] cobolParser.SignalContext context)
    {
        if (context.OFF() == null){
            signal.procedure = context.proc().GetText();
        }
        else{
            signal.procedure = null;
        }
        return DefaultResult;
    }
}